pp_addpm({At=>Top},<<'EOD');

use vars qw/ $VERSION /;
$VERSION = '0.11';

=head1 NAME

PDL::Slatec - PDL interface to the slatec numerical programming library

=head1 SYNOPSIS

 use PDL::Slatec;

 ($ndeg, $r, $ierr, $a) = polyfit($x, $y, $w, $maxdeg, $eps);

=head1 DESCRIPTION

This module serves the dual purpose of showing how to interface
PDL to an external library and providing various functions to 
interface to the slatec library. In due time, reasonable 
perl functions will be provided to take advantage of all 
the library but currently we only have


=head1 FUNCTIONS

=head2 eigsys

=for ref

Eigenvalues and eigenvectors of a real positive definite symmetric matrix.

=for usage

 ($eigvals,$eigvecs) = eigsys($mat)

Note: this function should be extended to calculate only eigenvalues if called
in scalar context!

=head2 matinv

=for ref

Inverse of a square matrix

=for usage

 ($inv) = matinv($mat)

=head2 polyfit

Convenience wrapper routine about the C<polfit> C<slatec> function.
Separates supplied arguments and return values.

=for ref

Fit discrete data in a least squares sense by polynomials
in one variable.

=for usage

 ($ndeg, $r, $ierr, $a) = polyfit($x, $y, $w, $maxdeg, $eps);

C<eps> is modified to contain the rms error of the fit.

=head2 polycoef

Convenience wrapper routine around the C<pcoef> C<slatec> function.
Separates supplied arguments and return values.

=for ref

Convert the C<polyfit>/C<polfit> coefficients to Taylor series form.

=for usage

 $tc = polycoef($l, $c, $a);

=head2 polyvalue

Convenience wrapper routine around the C<pvalue> C<slatec> function.
Separates supplied arguments and return values.

For multiple input x positions, a corresponding y position is calculated.

The derivatives PDL is one dimensional (of size C<nder>) if a single x
position is supplied, two dimensional if more than one x position is
supplied.

=for ref

Use the coefficients generated by C<polyfit> (or C<polfit>) to evaluate
the polynomial fit of degree C<l>, along with the first C<nder> of its
derivatives, at a specified point.

=for usage

 ($yfit, $yp) = polyvalue($l, $nder, $x, $a);


=head1 NOTES

Using this library requires a fortran compiler. The source for the routines
is provided for convenience.

=head1 AUTHOR

Copyright (C) 1997 Tuomas J. Lukka. 
Copyright (C) 2000 Tim Jenness.
All rights reserved. There is no warranty. You are allowed
to redistribute this software / documentation under certain
conditions. For details, see the file COPYING in the PDL 
distribution. If this file is separated from the PDL distribution, 
the copyright notice should be included in the file.



=cut
EOD

# for MDim, ld[str] is interpreted as "leading dimension of ..."

# Making the BAD BAD BAD assumption that PDL_Long == int 
# in fortran. BAD BAD BAD XXX (I'm going to regret this)

%ftypes = (S => F, D => D);

sub firstpar {
	$_[0] =~ /^\(([^),]+)[),]/ or die "Can't find first par from $_[0]";
	$1
}

# whether or not to append undercores

$uscore = (-e "f77_underscore" ? "_" : ""); 

sub defslatec {
	my($pname,$fnames,$argstr,$opts) = @_;
	my @args = map {/^\s*$/ ? () : $_} split ';', $argstr;
	my @args2 = map {
		/^\s*([a-zA-Z]+)\s+ 	# "Type name"
		  ((?:\[[^]]*\])?)\s* 	# Options
		  ([a-zA-Z]+)\s*      	# Par name
		  ((?:\([^)]*\))?)\s*$	# Dims
		 /x or die("Invalid slatec par $_");
		[$1,$2,$3,$4]} @args;
	my @ppars = map {
		if($_->[0] =~ /^M?Dim$/) {
			()
		} else {
		($_->[0] eq "Mat" and join '',@{$_}[1,2,3]) or
		($_->[0] eq "IntFlag" and "int ".join '',@{$_}[1,2,3]) or
		die "Invalid ppars ",(join ',',@$_),"\n";
		}
		} @args2;
	my @talts = map {defined $ftypes{$_} or die "FTYPE $_ NOT THERE\n";
			 [$ftypes{$_},$fnames->{$_}]}
			 	keys %$fnames;
	my $func = "\$T".(join '',map {$_->[0]} @talts) . "(" . 
	  (join ',',map {$_->[1].$uscore} @talts).")";

	my %lds = map {
		($_->[0] eq "Mat" and $_->[3] ne "()") ? 
			("ld".$_->[2] =>
			 "&\$PRIV(__".firstpar($_->[3])."_size)")
		: ()} @args2;

	my @funcpars =map {(($_->[0] eq "Mat" or
	  		     $_->[0] eq "IntFlag") and "\$P($_->[2])") or
			   ($_->[0] eq "Dim" and "&\$PRIV(__$_->[2]_size)") or
			   ($_->[0] eq "MDim" and $lds{$_->[2]}) or
			   die "Invalid args2";
			}  @args2;

	print "Pars: ",(join ';',@ppars),"\n";

	pp_def($pname,
		Pars => (join ';',@ppars),
		OtherPars => '',
		Code => (join '',@ifincode) . "\n " .
			$func . "  (". (join ',',@funcpars) . ");\n"
			. (join '',@ifoutcode),
		GenericTypes => [map {$_->[0]} @talts],
	        %$opts,
	);
}

pp_addhdr('
#include "SlatecProtos.h"

void MAIN__ () {                                                                
   /* Cheat to define MAIN__ symbol */                                          
   croak("This should never happen");                                           
}                                                                               
   
');


pp_add_exported('',"eigsys matinv fft fftb polyfit polycoef polyvalue");

pp_addpm(<<'END');

use PDL::Core;
use PDL::Basic;
use PDL::Primitive;
use strict;


# Note: handles only real symmetric positive-definite.

*eigsys = \&PDL::eigsys;

sub PDL::eigsys {
	my($h) = @_;
	$h = float($h);
	rs($h, 
		(my $eigval=PDL->null),
		(long (pdl (1))),(my $eigmat=PDL->null),
		(my $fvone = PDL->null),(my $fvtwo = PDL->null),
		(my $errflag=PDL->null)
	);
#	print $covar,$eigval,$eigmat,$fvone,$fvtwo,$errflag;
	if(sum($errflag) > 0) {
		barf("Non-positive-definite matrix given to eigsys: $h\n");
	}
	return ($eigval,$eigmat);
}

*matinv = \&PDL::matinv;

sub PDL::matinv {
	my($m) = @_;
	$m = $m->copy(); # Make sure we don't overwrite :(
	gefa($m,(my $ipvt=null),(my $info=null));
	if(sum($info) > 0) {
		barf("Uninvertible matrix given to inv: $m\n");
	}
	gedi($m,$ipvt,(pdl 0,0),(null),(long( pdl (1))));
	$m;
}

*det = \&PDL::det;
sub PDL::det {
	my($m) = @_;
	$m = $m->copy(); # Make sure we don't overwrite :(
	gefa($m,(my $ipvt=null),(my $info=null));
	if(sum($info) > 0) {
		barf("Uninvertible matrix given to inv: $m\n");
	}
	gedi($m,$ipvt,(my $det=null),(null),(long( pdl (10))));
	return $det->slice('(0)')*10**$det->slice('(1)');
}


sub prepfft {
	my($n) = @_;
	my $tmp = PDL->zeroes(float(),$n*3+15);
	$n = pdl $n;
	ezffti($n,$tmp);
	return $tmp;
}

*fft = \&PDL::fft;
sub PDL::fft {
	my($v) = @_;
	my $ws = prepfft($v->getdim(0));
	ezfftf($v,(my $az = PDL->null), (my $a = PDL->null), 
		  (my $b = PDL->null), $ws);
	return ($az,$a,$b);
}

sub rfft {
	my($az,$a,$b) = @_;
	my $ws = prepfft($a->getdim(0));
	my $v = $a->copy();
	ezfftb($v,$az,$a,$b,$ws);
	return $v;
}

# polynomial fitting routines
# simple wrappers around the SLATEC implementations

*polyfit = \&PDL::polyfit;
sub PDL::polyfit {
  barf 'Usage: polyfit($x, $y, $w, $maxdeg, $eps);'
    unless @_ == 5;
  
  # Create the output arrays
  my $r = PDL->null;

  # A array needs some work space
  my $sz = ((3*$_[0]->getdim(0)) + (3*$_[3]) + 3);
  my $a = $_[0]->zeroes( $sz ); # This should be of type $x

  # these are returned as integers
  my $ierr = PDL->null;
  my $ndeg = PDL->null;

  # Now call polfit
  polfit($_[0], $_[1], $_[2], $_[3], $ndeg, $_[4], $r, $ierr, $a);

  # Convert ierr and ndeg to simple scalars
  $ierr = $ierr->at();
  $ndeg = $ndeg->at();

  # Return the arrays
  return ($ndeg, $r, $ierr, $a);
}

*polycoef = \&PDL::polycoef;
sub PDL::polycoef {
  barf 'Usage: polycoef($l, $c, $a);'
    unless @_ == 3;

  # Allocate memory for return PDL
  # Simply l + 1 but cant see how to get PP to do this - TJ
  # Not sure the return type since I do not know 
  # where PP will get the information from
  my $tc = PDL->zeroes( abs($_[0]) + 1 );

  # Run the slatec routine
  pcoef($_[0], $_[1], $tc, $_[2]);

  # Return results
  return $tc;

}

*polyvalue = \&PDL::polyvalue;
sub PDL::polyvalue {
  barf 'Usage: polyvalue($l, $nder, $x, $a);'
    unless @_ == 4;

  # Two output arrays
  my $yfit = PDL->null;

  # This one must be preallocated and must take into account
  # the size of $x if greater than 1
  my $yp;
  print $_[2]->getdim(0),"\n";
  if ($_[2]->getdim(0) == 1) {
    $yp = $_[2]->zeroes($_[1]);
  } else {
    $yp   = $_[2]->zeroes($_[1], $_[2]->getdim(0));
  }

  # Run the slatec function
  pvalue($_[0], $_[2], $yfit, $yp, $_[3]);

  # Returns
  return ($yfit, $yp);

}

END

defslatec(
	'svdc',{S => 'ssvdc'},
	'Mat 		x	(n,p);
	 MDim 		ldx;
	 Dim 		n;
	 Dim 		p;
	 Mat 	[o]	s	(p);
	 Mat 	[o]	e	(p);
	 Mat 	[o] 	u	(n,p);
	 MDim 		ldu;
	 Mat 	[o] 	v	(p,p);
	 MDim 		ldv;
	 Mat 	[o] 	work	(n);
	 IntFlag   	job	();
	 IntFlag [o]	info	();
	',
	{Doc => 'singular value decomposition of a matrix'}
);

defslatec(
	'poco',{S => spoco, D => dpoco},
	'Mat		a	(n,n);
	 MDim		lda;
	 Dim		n;
	 Mat 		rcond	();
	 Mat	[o]	z	(n);
	 IntFlag [o]	info	();
	',
	{Doc => 'Factor a real symmetric positive definite matrix
		and estimate the condition number of the matrix.'}
);

defslatec(
	'geco',{S => sgeco, D => dgeco},
	'Mat		a	(n,n);
	 MDim		lda;
	 Dim		n;
	 IntFlag [o]	ipvt	(n);
	 Mat	 [o]	rcond	();
	 Mat	 [o]	z	(n);
	',
	{Doc => 'Factor a matrix using Gaussian elimination and estimate
            the condition number of the matrix.'}
);

defslatec(
	'gefa',{S => sgefa, D => dgefa},
	'Mat		a	(n,n);
	 MDim		lda;
	 Dim		n;
	 IntFlag [o]	ipvt	(n);
	 IntFlag [o]	info	();
	',
	{Doc => 'Factor a matrix using Gaussian elimination.'}
);

# XXX Ensure two == 2!!
defslatec(
	'podi',{S => spodi, D => dpodi},
	'Mat		a	(n,n);
	 MDim		lda;
	 Dim		n;
	 Mat	[o]	det	(two=2);
	 IntFlag	job	();
	',
	{Doc => 'Compute the determinant and inverse of a certain real
            symmetric positive definite matrix using the factors
            computed by SPOCO, SPOFA or SQRDC.'}
);

defslatec(
	'gedi',{S => sgedi, D => dgedi},
	'Mat		a	(n,n);
	 MDim		lda;
	 Dim		n;
	 IntFlag [o]	ipvt	(n);
	 Mat	 [o]	det	(two=2);
	 Mat	 [o]	work	(n);
	 IntFlag	job	();
	',
	{Doc => 'Compute the determinant and inverse of a matrix using the
            factors computed by SGECO or SGEFA.'}
);
	

defslatec(
	'gesl',{S => sgesl, D => dgesl},
	'Mat		a	(lda,n);
	 MDim		lda;
	 Dim		n;
	 IntFlag	ipvt	(n);
	 Mat		b	(n);
	 IntFlag	job	();
	',
	{Doc => 'Solve the real system A*X=B or TRANS(A)*X=B using the
            factors computed by DGECO or DGEFA'}
);

defslatec(
	'rs', {S => rsfoo},
	'MDim		lda;
	 Dim		n;
	 Mat		a	(n,n);
	 Mat	[o]	w	(n);
	 IntFlag	matz	();
	 Mat	[o]	z	(n,n);
	 Mat	[t]	fvone	(n);
	 Mat	[t]	fvtwo	(n);
	 IntFlag [o]	ierr	();
	',
	{Doc => 'This subroutine calls the recommended sequence of
     	subroutines from the eigensystem subroutine package (EISPACK)
     	to find the eigenvalues and eigenvectors (if desired)
     	of a REAL SYMMETRIC matrix.'}

);

# XXX wsave : at least 3n+15
defslatec(
	'ezffti', {S => ezffti},
	'IntFlag	n	();
	 Mat [o]	wsave(foo);
	',
	{Doc => 'Subroutine EZFFTI initializes the work array WSAVE
	which is used in both EZFFTF and EZFFTB.  The prime factorization
	of N together with a tabulation of the trigonometric functions
	are computed and stored in WSAVE.'}

);

# XXX Correct for azero, a and b
defslatec(
	'ezfftf', {S => ezfftf},
	'Dim		n;
	 Mat		r(n);
	 Mat [o]	azero();
	 Mat [o]	a(n);
	 Mat [o]	b(n);
	 Mat 		wsave(foo);
	'
);

defslatec(
	'ezfftb', {S => ezfftb},
	'Dim		n;
	 Mat  [o]	r(n);
	 Mat  		azero();
	 Mat		a(n);
	 Mat 		b(n);
	 Mat 		wsave(foo);
	'
);

defslatec(
	'polfit', {S => polfit, D => dpolft},
	'
	Dim             n;
	Mat             x(n);
        Mat             y(n);
	Mat             w(n);
	IntFlag         maxdeg ();
        IntFlag  [o]    ndeg   ();
        Mat      [o]    eps    ();
        Mat      [o]    r      (n);
	IntFlag  [o]    ierr   ();
	Mat      [o]    a      (foo);
	',
	{Doc => 'Fit discrete data in a least squares sense by polynomials
        in one variable. x(), y() and w() must be of the same type.'}
);


defslatec(
	'pcoef', {S => pcoef, D => dpcoef},
	'
	IntFlag  l ();
	Mat      c ();
	Mat [o]  tc (bar);
	Mat      a (foo);
	',
	{Doc => 'Convert the C<polfit> coefficients to Taylor series form.
         c and a() must be of the same type.'}
);

defslatec(
	'pvalue', {S => pvalue, D => dp1vlu},
	'
	IntFlag  l ();
	Dim      nder;
	Mat      x    ();
	Mat [o]  yfit ();
	Mat [o]  yp   (nder);
	Mat      a    (foo);
	',
	{Doc => 'Use the coefficients generated by C<polfit> to evaluate the
            polynomial fit of degree L, along with the first NDER of
            its derivatives, at a specified point. x and a must be of the
            same type.'}
);


pp_done();


